theory registration_in_end_to_end_mode
begin

builtins: hashing

functions: passKey/2

equations: passKey(kMaster, mSalt) = h(<kMaster, mSalt>)

//The client device generates a master secret kMaster by calling prng. Note that the user device has not yet a user ID.
//The user enters his/her email or phone number
//The client generates a salt value mSalt = prng(64). The email as well as salt and password key are sent to the home server.
rule gen_master_secret:
     [Fr(~kMaster), Fr(~mSalt)]
     -->
     [RegisterRequest(passKey(~kMaster, ~mSalt), $email, ~mSalt), !User($email, ~kMaster, ~mSalt), Out(<$email, passKey(~kMaster, ~mSalt), ~mSalt>)]

//the server stores the password key, salt and email. It sends out verification code via email. The code is valid for 10 min.
rule receive_and_store_user_data:
     let
        userInfo = <$email, passwordKey, mSalt>
     in
     [In(userInfo), Fr(~verificationCode)]
     -->
     [VerifyingUser(~verificationCode, userInfo), SendVerificationCode(~verificationCode)]

rule read_email:
     [SendVerificationCode(verificationCode)]
     --[CompromiseEmail()]->
     [Out(verificationCode), SendVerificationCode(verificationCode)]

rule write_email:
     [In(verificationCode)]
     --[CompromiseEmail()]->
     [SendVerificationCode(verificationCode)]

rule client_verify:
     [SendVerificationCode(verificationCode), !User($email, kMaster, mSalt)]
     --[ClientClickedVerify($email), UserPass(passKey(kMaster, mSalt))]->
     [Out(verificationCode)]

rule server_verify_client:
     let
        userInfo = <$email, passwordKey, mSalt>
     in
     [In(verificationCode), VerifyingUser(verificationCode, userInfo)]
     --[RegisteredUser(userInfo)]->
     [RegisteredUser(userInfo)]

lemma user_can_register:
      exists-trace
        "Ex email passwordKey mSalt #i #j.
          RegisteredUser(<email, passwordKey, mSalt>) @j
          & ClientClickedVerify(email) @i
          & i < j
          & not(Ex #r. CompromiseEmail() @r)"

lemma can_fake_email:
      exists-trace
      "Ex email passwordKey mSalt #i.
            RegisteredUser(<email, passwordKey, mSalt>) @i
            & not(Ex #r. CompromiseEmail() @r)
            & not(Ex #k. ClientClickedVerify(email) @k & UserPass(passwordKey) @k)"

end
